# 捕获列表

## 作用域

捕获列表中的变量存在于两个作用域——lambda 表达式定义的函数作用域以及 lambda 表达式函数体的作用域。前者是为了捕获变量，后者是为了使用变量。另外，标准还规定能捕获的变量是一个自动存储类型。简单来说就是非静态的局部变量。

## 捕获值和捕获引用

捕获列表的捕获方式分为捕获值和捕获引用。捕获值时将函数作用的变量复制到 lambda 表达式对象的内部，就如同 lambda 表达式的成员变量一样。

捕获引用的语法与捕获值只有一个 & 的区别，要表达捕获引用只需要在捕获变量之前加上 &，类似于去变量的指针。只不过这里捕获的引用而不是指针，在 lambda 表达式内可以直接使用变量名访问变量而不需要解引用。

``` c++
int main() {
    int x = 5, y = 8;
    auto foo = [&x, &y] { return x * y; };
}
```

上面这个例子只是读取变量的值，从结果上看两种捕获没有什么区别，但是如果加入变量的赋值操作，情况就不同了，请看下面的例子：

```c++
void bar1() {
    int x = 5, y = 8;
    auto foo = [x, y] {
        x += 1;		// 编译失败
        y += 2;		// 编译失败
        return x * y;
    };
    std::cout << foo() << std::endl;
}

void bar2() {
    int x = 5, y = 8;
    auto foo() = [&x, &y] {
        x += 1;
        y += 2;
        return x * y;
    };
    std::cout << foo() << std::endl;
}
```

上述带代码中 `bar1()` 无法通过编译，原因是无法改变捕获变量的值。这就引出了 lambda 表达式的一个特性：捕获的变量默认为常量，或者说 lambda 十一个常量函数（类似于常量成员函数）。`bar2()` 函数里的 lambda 表达式能够顺利地通过编译，虽然其函数内也有改变变量 x 和 y 的行为。这是因为捕获的变量默认为常量指的是变量本身，当变量按值捕获的时候，变量本身就是值，所以改变值就会发生错误。相反，在捕获引用的情况下，捕获变量实际上是一个引用，在函数体内改变的并不是引用本身，而是引用的值，所以并没有被编译器拒绝。

也可以对值捕获添加 mutable 修饰词对捕获值进行修改，但是虽然效果一样吗，但是与捕获引用并不是等价的，捕获值和捕获引用还是存在这本质的区别。捕获值可以修改内部捕获变量但是不会影响外部变量，而捕获引用都会修改。而且捕获值用 mutable 修饰词后，第二次调用 lambda 会被上次改变所影响。

对于捕获值的 lambda 表达式还有一点需要注意，捕获值的变量在 lambda 表达式定义时已经固定下来了，无论函数在 lambda 表达式定义后如何修改外部变量的值都不会发生变化，例如：

```c++
#include <iostream>

int main() {
    int x = 5, y = 8;
    auto foo = [x, &y]() mutable {
        x += 1;
        y += 2;
        std::cout << "lambda x = " << x << ",y = " << y << std::endl;
        return x * y;
    };
    x = 9;
    y = 20;
    foo();
}

// 运行结果：lambda x = 6, y = 22;
```

在上面代码中，虽然调用 foo 之前分别修改了 x 和 y 的值，但是捕获值的变量 x 依然延续着 lambda 定义时的值，而在捕获引用的变量 y 被重新赋值以后，lambda 表达式捕获的变量 y 的值也跟着发生了变化。