# 继承构造函数（C++11）

## 13.1 继承关系中的构造函数的困局

面对基类中大量的构造函数，不得不在派生类中定义同样多的构造函数，目的仅仅是转发构造参数，因为派生类本身并没有需要初始化的数据成员。单纯地转发构造函数不仅会导致代码地冗余，而且大量重复的代码也会让程序更容易出错。

## 13.2 使用继承构造函数

使用`using`关键字将基类的函数引入派生类。

```c++
class Base {
public:
    Base() : x_(0), y_(0.) {}
    Base(int x, double y) : x_(x), y_(y) {}
    Base(int x) : x_(x), y_(0.) {}
    Base(double y) : x_(0), y_(y) {} 
private:
    int x_;
    double y_;
};

class Derivec : public Base {
public:
    using Base::Base;
};
```

> 注意：
>
> 1. 派生类是隐式继承基类的构造函数，所以只有在程序中使用这些构造函数，编译器才会为派生类生成继承构造函数的代码。
> 2. 派生类不会继承基类的默认构造函数和复制构造函数。
> 3. 继承构造函数不会影响派生类默认构造函数的隐式声明，也就是说对于继承基类的构造函数的派生类，编译器依然会为其自动生成默认构造函数代码。
> 4. 在派生类中声明签名相同的构造函数会禁止继承相应的构造函数。
> 5. 派生类继承多个签名相同的函数会导致编译失败。
> 6. 继承构造函数的基类构造函数不能为私有