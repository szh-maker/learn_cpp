# std::initializer_list 详解

标准容器之所以能够支持列表初始化，离不开编译器支持的同时，必须满足一个条件：支持 `std::initializer_list` 为形参的构造函数。

注意：`std::initializer_list` 的 begin 和 end 函数并不是返回的迭代器对象，而是一个常量对象指针 const T*。

## 使用列表初始化的注意事项

### 隐式窄转换问题

#### 隐式转换的的规则

1. 从浮点型转换为整数类型
2. 从 long double 转换到 double 或 float，或从 double 转换到 float，除非转换源是常量表达式以及转换后的实际值在目标可以表示的值范围内
3. 整数类型或者非强枚举类型转换到浮点类型，除非转换源是常量表达式，转换后的实际值适合目标类型并且能够将生成的目标值转换回原始数据类型的原始值。
4. 从整数类型或非强枚举类型转换到不能代表所有原始类型值的整数型类型，除非源是一个常量表达式，其值在转换之后能够适合目标类型

### 列表初始化的优先级问题

如果一个类同时拥有满足列表初始化的构造函数，且其中一个是以 `std::initializer_list` 为参数，那么编译器将优先以 `std::initializer_list` 为构造函数。

## 指定初始化

为了提高数据成员初始化的可持续性和灵活性，C++20 标准中引入了指定初始化的特性。该特性允许指定初始化数据成员的名称，从而使代码意图更加明确。

```c++
struct Point {
    int x;
    int y;
};

Point p{ .x = 4, .y = 2 };
```

虽然这段代码中 Point 的初始化并不如 `Point p{ 4, 2 };` 方便，但是这个例子却很好地展现了指定初始化语法。实际上，当初始化的结构体的数据成员比较多且真正需要赋值的只有少数成员的时候，这样的指定初始化就非常好用了:

```c++
struct Point3D {
   int x;
   int y;
   int z;
};

Point3D p{ .z = 3 };	// x = 0, y = 0
```

注意：

1. 要求对象必须是个聚合体类型
2. 指定的数据成员必须是非静态成员，原因是静态成员不属于某个对象
3. 每个非静态数据成员只能初始化一次
4. 非静态数据成员的初始化必须按照声明顺序进行
5. 针对联合体中的数据成员只能初始化一次，不能同时指定
6. 不能嵌套指定初始化数据成员
7. 在 C++20 中，一旦使用指定初始化，就不能混用其他方法对数据成员初始化
8. 禁止指定初始化数组，原因是与 lambda 语法冲突