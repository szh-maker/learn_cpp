# 非静态数据成员默认初始化（C++11~C++20）

## 使用默认初始化

在 C++11 以前，对非静态数据成员初始化需要用到初始化列表，当类的数据成员和构造函数较多时，编写构造函数是一个令人头痛的问题。

为了在构造地时候初始化非静态数据成员，它们的初始化列表有一些冗余代码，而造成的后果是维护困难且容易出错。为了解决这种问题，C++11 标准提出了新的初始化方法，即在声明非静态数据成员的同时直接对其使用=或者{}初始化。在此之前只有类型为整型或者枚举类型的常量静态数据成员才有这种声明默认初始化待遇：

```c++
class X {
public:
    X() {}
    X(int a) : a_(a) {}
    X(double b) : b_(b) {}
    X(const std::string& c) : c_(c) {}
private:
    int a_ = 0;
    double b_{ 0. };
    std::string c_{ "hello world" };
};
```

以上代码使用了非静态数据成员默认初始化的方法，可以看出这种初始化方法更加清晰，每个构造函数只需要专注于特殊成员的初始化，而其他的数据成员则默认使用声明时初始化的值。

> 注意：
>
> 1. 不要使用括号()对非静态数据成员进行初始化，因为这样会造成解析问题，所以会编译失败。
> 2. 不要用 auto 来声明和初始化非静态数据成员，虽然这一点看起来合理，但是 C++ 并不允许这么做。

## 位域的默认初始化

在 C++20 中可以对位域进行默认初始化。

```c++
struct S {
    int y : 8 = 11;
    int z : 4 {7};
};

// 注意：当位域的常量表达式是一个条件表达式
int a;
struct S2 {
	int y : true ? 8 : a = 42;
  	int z : 1 || new int{0};
};
```

因为最大化识别标识符的解析规则让=42和{0}不可能存在解析的顶层。

所以需要使用括号明确优先级来解决问题。

```c++
int a;
struct S2 {
  	int y : (true ? 8 : a) = 42;
    int z : (1 || new int) {0}
};
```